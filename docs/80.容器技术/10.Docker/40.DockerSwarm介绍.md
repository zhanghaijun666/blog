---
title: DockerSwarm介绍
date: 2023-02-27
category: 
  - 容器技术
  - Docker
tag: 
  - Docker
---
<!-- more -->
[[toc]]

## 相关地址

- <https://github.com/docker-archive/classicswarm>
- <https://github.com/moby/swarmkit>

## 介绍

> Docker Swarm是管理跨节点容器的编排工具，Docker 官方容器编排项目。`Docker Swarm`和`Docker Compose`一样，都是编排工具，但不同的是:
>
> `Docker Compose`只能编排单节点上的容器。
>
> `Docker Swarm`将一群Docker节点虚拟化为一个主机，使得用户只要在单一主机上操作就能完成对整个容器集群的管理工作。

## 架构图

Swarm deamon只是一个调度器(Scheduler)加路由器(router),Swarm自己不运行容器，它只是接受Docker客户端发来的请求，调度适合的节点来运行容器，这就意味着，即使Swarm由于某些原因挂掉了，集群中的节点也会照常运行，放Swarm重新恢复运行之后，他会收集重建集群信息。

![swarm](./library/swarm%E6%9E%B6%E6%9E%84%E5%9B%BE.png)

Swarm是典型的master-slave结构，通过发现服务来选举manager。manager是中心管理节点，各个node上运行agent接受manager的统一管理，集群会自动通过Raft协议分布式选举出manager节点，无需额外的发现服务支持，避免了单点的瓶颈问题，同时也内置了DNS的负载均衡和对外部负载均衡机制的集成支持

## Swarm优点

- 任何规模都有高性能表现
- 灵活的容器调度
- 服务的持续可用性
- 和 Docker API 及整合支持的兼容性
- `Docker Swarm`为`Docker`化应用的核心功能提供原生支持。

## Swarm核心

### 1、Swarm

集群的管理和编排是使用嵌入`docker`引擎的`SwarmKit`，可以在`docker`初始化时启动`swarm`模式或者加入已存在的`swarm`

### 2、Node

`Node`是docker引擎集群的一个实例。管理节点（manager nodes）和工作节点（worker nodes）

### 3、Service服务

一个服务是任务的定义，管理机或工作节点上执行。它是群体系统的中心结构，是用户与群体交互的主要根源。创建服务时，你需要指定要使用的容器镜像。

### 4、Task任务

任务是在docekr容器中执行的命令，Manager节点根据指定数量的任务副本分配任务给worker节点

## 使用方法

### 1、集群命令

```bash
## 检查是否开启Swarm模式
docker info | grep 'Swarm: active'
## 初始化manager节点
docker swarm init
docker swarm init --advertise-addr 192.168.60.101
docker swarm join-token manager
docker swarm join --token xxxxxx
## 下线节点，使之不参与任务分派
docker node update --availability drain node2
## 上线节点，使之参与任务分派
docker node update --availability active node2
## 节点离开集群
docker swarm leave
```

### 2、服务命令

```bash
## 查看集群资源
docker node ls
docker network ls
docker service ls
docker service ps
docker stack ls

## 创建网络
docker network create --attachable --driver overlay --subnet=172.66.0.0/16 --gateway=172.66.0.1 <NETWORK_NAME>

## 使用指定的网络部署一个服务
docker service create --replicas 1 --network <NETWORK_NAME> --name my_nginx -p 80:80 nginx:latest
docker service ps my_nginx
## 动态扩缩容
docker service scale my_nginx=4
docker service update --relipcas 4 my_nginx

## 滚动更新
docker service update --image nginx:2.0 --update-parallelism 2 --update-delay 20s my_nginx

## 删除服务
docker service rm my_nginx
```

### 3、任务命令

> 任务编排文件 cat nginx.yaml

```yaml
version: "3.9"
services:
  web:
    image: nginx:1.13-alpine
    hostname: "ngin-node-{{ .Task.Slot }}"
    environment:
      - TZ=Asia/Shanghai
    ports:
      - "80-88:80-88"
  networks:
      - overlay
  deploy:
    mode: replicated
    replicas: 7
    restart_policy:                     ## 重启设置
      condition: on-failure             ## 在运行失败的时候
      delay: 10s                        ## 发生错误多长时间执行重启
      max_attempts: 3                   ## 在放弃之前尝试重新启动容器的次数(默认值: 永远不要放弃)
      window: 120s                      ## 设置重启的超时时间
    update_config:
      parallelism: 2                    ## 每次更新容器数量
      delay: 10s                        ## 更新一组容器之间的等待时间
      failure_action: pause             ## 如果更新失败了怎么办，选择 continue、 rollback 或 pause (默认值: pause)
      monitor: 500ms                    ## 每个容器更新后，持续观察是否失败了的时间
      max_failure_ratio: 0.5            ## 在更新过程中可以容忍的故障率
    rollback_config:
      parallelism: 1                    ## 每次回滚的容器数量。如果设置为0，所有容器同时回滚。
      delay: 0s                         ## 每个容器组回滚之间的等待时间(默认值为0)
      monitor: 500ms                    ## 每次任务更新后监视故障后的持续时间
    healthcheck:
      test: ["CMD", "wget", "-qO", "-", "http://localhost"] ## 定义检测的命令 
      interval: 2s                      ## 命令执行间隔，默认30秒
      timeout: 2s                       ## 命令超时时间，默认30秒
      retries: 3                        ## 命令失败重试次数
      start_period: 2s                  ## 启动延时，即容器启动后多久开始执行检测
    resources:                          ## 资源限制
        limits:
          # cpus: '0.001'
          memory: 1024M
        reservations:
          # cpus: '0.001'
          memory: 64M
networks:
  overlay:
```

> 执行任务

```bash
docker stack deploy -c nginx.yml my_nginx
```

## 高可用性（HA）

有以下两条最佳实践原则。

- 部署奇数个管理节点。
- 不要部署太多管理节点（建议 3 个或 5 个）。
