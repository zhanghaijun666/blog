---
title: Kubernetes从概念到实践
date: 2023-02-20 16:07:59

category: 
  - 云原生
  - kubernetes
tag: 
  - kubernetes
---

![sfOBKH.png](https://s3.ax1x.com/2021/01/21/sfOBKH.png)

<!-- more -->

[[toc]]

## 在 K8s 运行的服务，分为无状态服务和有状态服务

- 无状态服务，即 Web 服务器、代理和应用程序代码这样的应用程序，它们可以处理数据但不进行存储。
- 有状态服务，即路由器、CDN（内容传送网络）、streaming 服务器和认证服务器。从部署开始，这些容器就开始与上游镜像不同了，时间越长它们的差异越大。

## Pod

> Pod 是 Kubernetes 的一个最小调度以及资源单元。<br/>
> 是 Kubernetes 集群中的一个应用实例，总是部署在同一个节点 Node 上。<br/>
> Pod 中包含了一个或多个容器，还包括了存储、网络等各个容器共享的资源。<br/>
> 官网地址：[https://kubernetes.io/zh/docs/concepts/workloads/pods/](https://kubernetes.io/zh/docs/concepts/workloads/pods/)

::: details 单独定义一个 pod,这个没有没有副本控制器管理，也没有对应 deployment

```bash
# 自主式的pod: 单独定义一个pod,这个没有没有副本控制器管理，也没有对应deployment
cat > init-pod.yaml <<EOF
apiVersion: v1
kind: Pod
metadata:
 name: init-pod
 labels:
   app: myapp
spec:
 containers:
 - name: myapp
   image: hub.kaikeba.com/library/myapp:v1
EOF
```

:::

::: details 常用命令

```bash
# 查看日志
kubectl logs first-pod
# 查看标签
kubectl get pods --show-labels
# 根据标签来查询Pod。
kubectl get pods -l first-pod --show-labels
# 增加标签
kubectl label pod first-pod tir=frontend
# 修改标签
kubectl label pod first-pod tir=unkonwn --overwrite
# 可以将标签显示为列
kubectl get pods -L app,tir
# 删除Pod
kubectl delete pods first-pod
# 根据标签选择器删除。
kubectl delete pods -l tir=backend
# 登录pod内部容器：
kubectl exec -it first-pod – sh
```

:::

## Deployment

> `deployment` 是用来管理无状态应用的，面向的集群的管理，而不是面向的是一个不可变的个体。<br/> > `eployment` 为 `Pod` 和 `ReplicaSet` 之上，提供了一个声明式定义方法。<br/>
> 官网地址：[https://kubernetes.io/zh/docs/tasks/run-application/run-stateless-application-deployment/](https://kubernetes.io/zh/docs/tasks/run-application/run-stateless-application-deployment/)

```bash
# 命令式声明deployment
kubectl run myapp-deploy --replicas=3 --labels="app=myapp" --image=ikubernetes/myapp:v1 --port=80
# 扩容指令
kubectl scale deployment myapp-deploy --replicas=6
```

::: details yaml 方式声明 deployment (推荐使用)

```bash
rm -rf myapp-deploy.yaml
cat > myapp-deploy.yaml <<EOF
apiVersion: apps/v1
kind: Deployment
metadata:
  name: myapp-deploy
  namespace: default
spec:
  replicas: 3
  selector:
    matchLabels:
      app: myapp
      release: dev
  template:
    metadata:
      labels:
        app: myapp
        release: dev
    spec:
      containers:
      - name: myapp-containers
        image: ikubernetes/myapp:v1
        ports:
        - name: http
          containerPort: 80
EOF
kubectl apply -f myapp-deploy.yaml

# 查询信息命令
kubectl get deployment
kubectl get rs
kubectl get pod
kubectl get pod -l app=myapp -w
kubectl get rs -o wide

# 删除全部应用
kubectl delete deployment --all
kubectl delete rs --all
kubectl delete pod --all

# 更新 修改yaml文件
kubectl apply -f myapp-deploy.yaml
# 命令形式升级,服务更新指令
kubectl set image deployment/myapp-deploy ikubernetes/myapp2:v0.7 --record
kubectl describe deployment

# 回滚操作
# 查看现在有几个版本
kubectl rollout history deploy  myapp-deploy
# 回滚到第0版(默认回滚上一版，可以通过 --to-revision指定版本)
kubectl rollout undo deploy  myapp-deploy --to-revision=0
# 查看回滚情况
kubectl get pods -l  app=myapp -w
```

:::

## Service

> 为屏蔽 pod 实例的动态变化和对多实例的负载均衡，引入了 Service 这个资源对象<br/>
> 四层的负载均衡（默认轮询策略）和服务的发现。<br/>

#### Service 的 type 类型不同，可分成 4 种模式：

- ClusterIP (默认方式) <br/>
  根据是否生成 ClusterIP 又可分为普通 Service 和 Headless Service 两类：
  > `普通Service`：通过为 Kubernetes 的 Service 分配一个集群内部可访问的固定虚拟 IP（Cluster IP），实现集群内的访问。为最常见的方式。<br/> > `Headless Service`：该服务不会分配 Cluster IP，也不通过 kube-proxy 做反向代理和负载均衡。而是通过 DNS 提供稳定的网络 ID 来访问，DNS 会将 headless service 的后端直接解析为 podIP 列表。主要供 StatefulSet 使用。<br/>
- NodePort <br/>
  service 的 port 映射到集群内每个节点的相同一个端口，实现通过 nodeIP:nodePort 从集群外访问服务。
- LoadBalancer<br/>
  服务通过云提供商的负载均衡器功能可以从外部访问。阿里云、AWS、Azure 都提供了这一功能。
- ExternalName<br/>
  此模式要求 kube-dns 的版本为 1.7 或以上。最大的不同是重定向依赖的是 dns 层次，而不是通过 kube-proxy。

::: details 命令式声明 service

```bash
kubectl expose deployment myapp-deploy --type=ClusterIP --target-port=8080 --port=80 --name=myapp-service
kubectl port-forward service/myapp-service 8080:8080
```

::: details yaml 文件声明 service （推荐）

```bash
cat > my-service.yaml << EOF
apiVersion: v1
kind: Service
metadata:
  name: myapp-service
  namespace: default
spec:
  type: NodePort
  selector:
    app: myapp
    release: dev
  ports:
    - name: http
      port: 8080
      targetPort: 80
EOF
kubectl create -f my-service.yaml
```

:::

::: details 常用命令

```bash
kubectl get svc
kubectl get svc -o wide
kubectl describe service my-service
```

## 外网访问

1. ssh 端口转发（本地执行）

```bash
# 本地的 7777端口转发到 10.111.63.238:80（service地址）
ssh -L 7777:10.111.63.238:80 root@192.16.18.111
```

2. iptables 端口转发（存在问题，那位大神可以指点一二）

```bash
# 开启允许转发
sysctl -w net.ipv4.ip_forward=1

# 清除iptables nat
iptables -t nat -F
# 查看现用所有iptables规则
iptables -t nat -L -n --line-number
# 添加端口转发规则
# 规则解释:在forward表里添加规则,允许转发向6666端口转发的tcp连接数据
iptables -I FORWARD -p tcp --dport 6666 -j ACCEPT
iptables -t nat -I PREROUTING -p tcp --dport 6666 -j DNAT --to-destination 10.111.63.238:80
iptables -t nat -I POSTROUTING -p tcp --dport 80 -j MASQUERADE
service iptables save
service iptables restart

iptables -t nat -A OUTPUT -p tcp --dport 6666  -j DNAT --to-destination 10.111.63.238:80
iptables -t nat -A PREROUTING -p tcp --dport 6666 -j DNAT --to-destination 10.111.63.238:80
iptables -t nat -A POSTROUTING -p tcp -d 10.111.63.238   --dport 80 -j SNAT --to-source 192.16.18.111

# 查看ip的映射规则
ipvsadm -Ln
# 查看apiVersion
kubectl api-versions
```

3. Ingress nginx
   > 下面介绍

## Ingress nginx (7 层负载均衡方案)

> 安装地址：[https://github.com/kubernetes/ingress-nginx/blob/master/docs/deploy/index.md](https://github.com/kubernetes/ingress-nginx/blob/master/docs/deploy/index.md)
> Ingress 是对集群中服务的外部访问进行管理的 API 对象，典型的访问方式是 HTTP。<br/>
> Ingress 可以提供负载均衡、SSL 终结和基于名称的虚拟托管。<br/>
> 官方地址：[https://kubernetes.io/zh/docs/concepts/services-networking/ingress/](https://kubernetes.io/zh/docs/concepts/services-networking/ingress/)<br/>

::: details yaml 文件创建 ingress

```bash
cat myapp-ingress.yaml << EOF
apiVersion: extensions/v1beta1
kind: Ingress
metadata:
  name: myapp-ingress
  annotations:
    nginx.ingress.kubernetes.io/rewrite-target: /
spec:
  rules:
  # 定义访问域名
  - host: my.ingress.com
    http:
      paths:
     # 访问前缀
      - path: /myapp
        backend:
          # 转发到哪个server下
          serviceName: myapp-service
          servicePort: 8080
      - path: /app
        backend:
          serviceName: myapp-service
          servicePort: 8080
EOF
kubectl apply -f myapp-ingress.yaml
# 查看详情
kubectl get ingress
kubectl describe ingress myapp-ingress
```

:::

## Namespace

> 用来做一个集群内部的逻辑隔离的，它包括鉴权、资源管理等。<br/>
> 同一个 Namespace 中的资源需要命名的唯一性，不同的 Namespace 中的资源可以重名。<br/>

## Label 标签

> Label 可以附加在各种资源对象上，如 Node、Pod、Service、RS 等。<br/>
> 一个资源对象可以定义任意数量的 Label，同一个 Label 也可以被添加到任意数量的资源对象上去。<br/>
> 可以通过标签精确的定位每一个资源对象，从而实现 k8s 资源对象精细化控制（管理）<br/>

## HPA

Horizontal Pod Autoscaling 仅适用于 Deployment 和 ReplicaSet,在 V1 版本中仅支持根据 Pod 的 CPU 利用率扩容，在 vlalpha 版本中，支持根据内存和用户自定义的 metric 扩缩容

## DeamonSet

> DeamonSet 部署服务的时候，把一个服务确保部署到每一个节点中；<br/>
> Deamonset 一般用来部署每一个节点都需要部署的服务；比如： logstash<br/>

## DNS 域名解析

Kubernetes 服务部署中，通过名称解析服务 ip，实现服务的访问；尤其在微服务部署的时候；
