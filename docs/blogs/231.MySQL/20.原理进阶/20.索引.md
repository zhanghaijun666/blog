---
order: 20
title: 索引
date: 2024-05-29 17:55:06
tags:
- 原理进阶

---
索引篇

书中的目录，就是充当索引的角色，方便我们快速查找书中内容，是以空间换时间的设计思想。

换到数据库中，索引的定义就是帮助存储引擎快速获取数据的一种数据结构，形象的说就是索引是数据的目录。索引和数据是位于存储引擎中的。

# 全表扫描和索引扫描的区别？

索引树扫描我们是比较熟悉的，它就是会遍历聚簇索引树，底层是一颗B+树，叶子节点存储了所有的实际行数据。其实，全表扫描也是扫描的聚簇索引树，因为聚簇索引树的叶子节点中存储的就是实际数据，只要扫描遍历聚簇索引树就可以得到全表的数据了。

对于索引扫描来讲，它只需要读取叶子节点的所有key，也就是索引的键，而不需要读取具体的data行数据（例如，主键索引只需要知道key即id即可，不用知道data值；普通索引比如是name，也如果有建立name索引，那name就是key，也照样不需要知道data数据）；而对于全表扫描来说，它无法仅仅通过读取索引列获得需要的数据，还需要读取具体的data数据才能获取select中指定的非索引列的具体值（例如，用like模糊搜索的时候，必须要获取data数据才能比对）。所以，全表扫描的效率相比于索引树扫描相对较低一点，但是差距不是很大。

说白了，就是索引扫描只需要看目录不需要翻到具体哪一页就知道是否为想查的数据；全表扫描是看目录不顶用了，必须要一页页一条条查过去才可以。索引扫描只会查符合的数据，全表扫描会查所有的数据，后者会把Buffer Pool大量热数据挤走。

# 索引的分类

按「数据结构」分类：B+tree索引、Hash索引、Full-text索引。

按「物理存储」分类：聚簇索引（主键索引）、二级索引（辅助索引）。

按「字段特性」分类：主键索引、唯一索引、普通索引、前缀索引。

按「字段个数」分类：单列索引、联合索引。

### 按数据结构分类

B+Tree 索引、HASH 索引、Full-Text 索引。

InnoDB 是在 MySQL 5.5 之后成为默认的 MySQL 存储引擎，B+Tree 索引类型也是 MySQL 存储引擎采用最多的索引类型。

在创建表时，InnoDB 存储引擎会根据不同的场景选择不同的列作为索引：

如果有主键，默认会使用主键作为聚簇索引的索引键（key）；

如果没有主键，就选择第一个不包含 NULL 值的唯一列作为聚簇索引的索引键（key）；

在上面两个都没有的情况下，InnoDB 将自动生成一个隐式自增 id 列作为聚簇索引的索引键（key）；

其它索引都属于辅助索引（Secondary Index），也被称为二级索引或非聚簇索引。创建的主键索引和二级索引默认使用的是 B+Tree 索引。

B+Tree 是一种多叉树，叶子节点才存放数据，非叶子节点只存放索引（主键值），而且每个节点里的数据是按主键顺序存放的。每一层父节点的索引值都会出现在下层子节点的索引值中，因此在叶子节点中，包括了所有的索引值信息，并且每一个叶子节点都有两个指针，分别指向下一个叶子节点和上一个叶子节点，形成一个双向链表。（下图双向链表只画了单向）

![img](https://baiyunshan.flowus.net.cn/oss/f59cf394-13c9-4f1c-83ec-e99e8fe9b78b/image.png?time=1713609900&token=aae90decbbe9ceef1a35ec2d4ceab2c6&role=sharePaid)

#### B+Tree的主键索引

示例：主键索引

Java

复制

1

```
select * from product where id= 5;
```

这条语句使用了主键索引查询 id 号为 5 的商品。查询过程是这样的，B+Tree 会自顶向下逐层进行查找：

将 5 与根节点的索引数据 (1，10，20) 比较，5 在 1 和 10 之间，所以根据 B+Tree的搜索逻辑，找到第二层的索引数据 (1，4，7)；

在第二层的索引数据 (1，4，7)中进行查找，因为 5 在 4 和 7 之间，所以找到第三层的索引数据（4，5，6）；

在叶子节点的索引数据（4，5，6）中进行查找，然后我们找到了索引值为 5 的行数据。

数据库的索引和数据都是存储在硬盘的，我们可以把读取一个节点当作一次磁盘 I/O 操作。那么上面的整个查询过程一共经历了 3 个节点，也就是进行了 3 次 I/O 操作。

B+Tree 存储千万级的数据只需要 3-4 层高度就可以满足，这意味着从千万级的表查询目标数据最多需要 3-4 次磁盘 I/O，所以B+Tree 相比于 B 树和二叉树来说，最大的优势在于查询效率很高，因为即使在数据量很大的情况，查询一个数据的磁盘 I/O 依然维持在 3-4次（分支数存在冗余，每个节点可以有上百个分支）。

#### B+Tree的二级索引

主键索引的 B+Tree 和二级索引的 B+Tree 区别如下：

主键索引的 B+Tree 的叶子节点存放的是实际数据，所有完整的用户记录都存放在主键索引的 B+Tree 的叶子节点里；

二级索引的 B+Tree 的叶子节点存放的是主键值，而不是实际数据。

将前面的商品表中的 product_no （商品编码）字段设置为二级索引：

![img](https://baiyunshan.flowus.net.cn/oss/5916d3fb-924b-4044-be80-7e5b8f741b05/image.png?time=1713609900&token=fdc8e56f4ecd9d8d4aae2339c2106c18&role=sharePaid)

其中非叶子的 key 值是 product_no（图中橙色部分），叶子节点存储的数据是主键值（图中绿色部分）。

示例：二级索引

select \* from product where product_no = '0002';

会先检二级索引中的 B+Tree 的索引值（商品编码，product_no），找到对应的叶子节点，然后获取主键值，然后再通过主键索引中的 B+Tree 树查询到对应的叶子节点，然后获取整行数据。这个过程叫「回表」，也就是说要查两个 B+Tree 才能查到数据。

不过，当查询的数据是能在二级索引的 B+Tree 的叶子节点里查询到，这时就不用再查主键索引查。这种在二级索引的 B+Tree 就能查询到结果的过程就叫作「覆盖索引」，也就是只需要查一个 B+Tree 就能找到数据。

#### 为什么MySQL InnoDB选择B+tree作为索引的数据结构？

MySQL数据结构解析：https://mp.weixin.qq.com/s/w1ZFOug8-Sa7ThtMnlaUtQ

_1、B+Tree vs B Tree（多叉树）_

① B+Tree 只在叶子节点存储数据，而 B 树 的非叶子节点也要存储数据，所以 B+Tree 的单个节点的数据量更小，在相同的磁盘 I/O 次数下，就能查询更多的节点。

② 而且B树用来做范围查询，需要用中序遍历，涉及多个节点的磁盘I/O问题，导致速度下降。

③ 在存储某个位于底层的节点（比如A）的时候，非A记录节点里的记录数据会从磁盘加载到内存，占用额外内存资源。

另外，B+Tree 叶子节点采用的是双链表连接，适合 MySQL 中常见的基于范围的顺序查找，而 B 树无法做到这一点。

_2、B+Tree vs 二叉树_

对于有 N 个叶子节点的 B+Tree，其搜索复杂度为O(logdN)，其中 d 表示节点允许的最大子节点个数为 d 个。

在实际的应用当中， d 值是大于100的，这样就保证了，即使数据达到千万级别时，B+Tree 的高度依然维持在 3~4 层左右，也就是说一次数据查询操作只需要做 3~4 次的磁盘 I/O 操作就能查询到目标数据。

而二叉树的每个父节点的儿子节点个数只能是 2 个，意味着其搜索复杂度为 O(logN)，这已经比 B+Tree 高出不少，因此二叉树检索到目标数据所经历的磁盘 I/O 次数要更多。

_3、B+Tree vs Hash_

Hash 在做等值查询的时候效率贼快，搜索复杂度为 O(1)。

但是 Hash 表不适合做范围查询，它更适合做等值的查询，这也是 B+Tree 索引要比 Hash 表索引有着更广泛的适用场景的原因。

### 按物理存储分类

聚簇索引（主键索引）、二级索引（辅助索引）。

主键索引的 B+Tree 的叶子节点存放的是实际数据，所有完整的用户记录都存放在主键索引的 B+Tree 的叶子节点里；

二级索引的 B+Tree 的叶子节点存放的是主键值，而不是实际数据。

### 按字段特性分类

主键索引、唯一索引、普通索引、前缀索引。

主键索引：建立在主键字段上的索引，通常在创建表的时候一起创建，一张表最多只有一个主键索引，索引列的值不允许有空值。

唯一索引：唯一索引建立在 UNIQUE 字段上的索引，一张表可以有多个唯一索引，索引列的值必须唯一，但是允许有空值。

普通索引：普通索引就是建立在普通字段上的索引，既不要求字段为主键，也不要求字段为 UNIQUE。

前缀索引：对文本的前几个字符建立索引（具体是几个字符在建立索引时去指定），比如以产品名称的前 10 位来建索引，这样建立起来的索引更小，查询效率更快！

### 按字段个数分类

单列索引、联合索引（复合索引）。

建立在单列上的索引称为单列索引，比如主键索引，单列的普通索引；

建立在多列上的索引称为联合索引，比如，将商品表中的 product_no 和 name 字段组合成联合索引(product_no, name)；

联合索引

CREATE INDEX index_product_no_name ON product(product_no, name);

![img](https://baiyunshan.flowus.net.cn/oss/f5a7fe62-79e1-4910-884a-50952ccf7d6f/image.png?time=1713609900&token=07234d401144a4ab9fdeec959deafe62&role=sharePaid)

使用联合索引时，存在最左匹配原则，也就是按照最左优先的方式进行索引的匹配。例如建立a,b,c联合索引，那么就是从a到b到c，先a顺序排列，然后再按b顺序排列，最后才按c顺序排列。所以索引的时候比较要有where a="xx"，否则b和c肯定没顺序。直接执行where b = 2这种查询条件没有办法利用联合索引的，利用索引的前提是索引里的 key 是有序的。只有在 a 相同的情况才，b 才是有序的。

#### 联合索引范围查询

Q1: select \* from t_table where a > 1 and b = 2，联合索引（a, b）哪一个字段用到了联合索引的 B+Tree？

Q1 这条查询语句只有 a 字段用到了联合索引进行索引查询，而 b 字段并没有使用到联合索引。

联合索引是先按照a字段的值排序。a字段是按照顺序存储的，故用到了联合索引的B+tree。但在a>1条件的索引记录范围里，b字段是无序的，如：

a 字段值为 5 的记录，该记录的 b 字段值为 8；

a 字段值为 6 的记录，该记录的 b 字段值为 10；

a 字段值为 7 的记录，该记录的 b 字段值为 5；

因此，我们不能根据查询条件 b = 2 来进一步减少需要扫描的记录数量（b 字段无法利用联合索引进行索引查询的意思）。

Q2: select \* from t_table where a >= 1 and b = 2，联合索引（a, b）哪一个字段用到了联合索引的 B+Tree？

Q2 这条查询语句 a 和 b 字段都用到了联合索引进行索引查询。

虽然在符合 a>= 1 条件的二级索引记录的范围里，b 字段的值是「无序」的，但是对于符合 a = 1 的二级索引记录的范围里，b 字段的值是「有序」的。所以对于a=1的情况，可以直接从b=2开始扫描直至不符合，而不用全部都扫描一遍。

Q3: SELECT \* FROM t_table WHERE a BETWEEN 2 AND 8 AND b = 2，联合索引（a, b）哪一个字段用到了联合索引的 B+Tree？

因为在MySQL中，BETWEEN是包含两个边界的，所以就是有=的情况，故和Q2的情况相同。a和b都用到了联合索引进行索引查询。

Q4: SELECT \* FROM t_user WHERE name like 'j%' and age = 22，联合索引（name, age）哪一个字段用到了联合索引的 B+Tree？

name和age都用到了联合索引进行索引查询。

由于联合索引（二级索引）是先按照 name 字段的值排序的，所以前缀为 ‘j’ 的 name 字段的二级索引记录都是相邻的， 于是在进行索引扫描的时候，可以定位到符合前缀为 ‘j’ 的 name 字段的第一条记录，然后沿着记录所在的链表向后扫描，直到某条记录的 name 前缀不为 ‘j’ 为止。

所以 a 字段可以在联合索引的 B+Tree 中进行索引查询，形成的扫描区间是['j','k')。

但是对于符合 name = j 的二级索引记录的范围里，age字段的值是「有序」的。

综上所示，联合索引的最左匹配原则，在遇到范围查询（如 >、<）的时候，就会停止匹配，也就是范围查询的字段可以用到联合索引，但是在范围查询字段的后面的字段无法用到联合索引。注意，对于 >=、<=、BETWEEN、like 前缀匹配的范围查询，并不会停止匹配，前面我也用了四个例子说明了。

#### 索引下推

对于查询语句：select \* from table where a > 1 and b = 2，只有a字段能用到索引，当在联合索引的B+tree找到第一个满足条件的主键值后，还需要判断其他条件是否满足（b是否为2）：

在 MySQL 5.6 之前，只能从主键值开始一个个回表，到「主键索引」上找出数据行，再对比 b 字段值。

而 MySQL 5.6 引入的索引下推优化（index condition pushdown)， 可以在联合索引遍历过程中，对联合索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。

#### 索引区分度

另外，建立联合索引时的字段顺序，对索引效率也有很大影响。越靠前的字段被用于索引过滤的概率越高，实际开发工作中建立联合索引时，要把区分度大的字段排在前面，这样区分度大的字段越有可能被更多的 SQL 使用到。

区分度 = 某个字段 column 不同值的个数 / 表的总行数。

例如：性别的区分度就很低，不合适放前面，ID号码区分度就特别高。

#### 联合索引进行排序

针对这样的查询语句如何提高

select \* from order where status = 1 order by create_time asc

如果只用到 status 的索引，但是这条语句还要对 create_time 排序，这时就要用文件排序 filesort，也就是在 SQL 执行计划中，Extra 列会出现 Using filesort。

可以给status和create_time列建立一个联合索引，这样可以避免 MySQL 数据库发生文件排序。

所以，要利用索引的有序性，在 status 和 create_time 列建立联合索引，这样根据 status 筛选后的数据就是按照 create_time 排好序的，避免在文件排序，提高了查询效率。

# 什么时候需要 / 不需要创建索引？

索引最大的好处是提高查询速度，但是索引也是有缺点的，比如：

需要占用物理空间，数量越大，占用空间越大；

创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增大；

会降低表的增删改的效率，因为每次增删改索引，B+ 树为了维护索引有序性，都需要进行动态维护。

### 那些场景使用索引？

字段有唯一性限制的，比如商品编码；

经常用于 WHERE 查询条件的字段，这样能够提高整个表的查询速度，如果查询条件不是一个字段，可以建立联合索引。

经常用于 GROUP BY 和 ORDER BY 的字段，这样在查询的时候就不需要再去做一次排序了，因为我们都已经知道了建立索引之后在 B+Tree 中的记录都是排序好的。

### 什么时候不需要创建索引？

WHERE 条件，GROUP BY，ORDER BY 里用不到的字段，索引的价值是快速定位，如果起不到定位的字段通常是不需要创建索引的，因为索引是会占用物理空间的。

字段中存在大量重复数据，不需要创建索引，比如性别字段，只有男女，如果数据库表中，男女的记录分布均匀，那么无论搜索哪个值都可能得到一半的数据。在这些情况下，还不如不要索引，因为 MySQL 还有一个查询优化器，查询优化器发现某个值出现在表的数据行中的百分比很高的时候，它一般会忽略索引，进行全表扫描。

表数据太少的时候，不需要创建索引；

经常更新的字段不用创建索引，比如不要对电商项目的用户余额建立索引，因为索引字段频繁修改，由于要维护 B+Tree的有序性，那么就需要频繁的重建索引，这个过程是会影响数据库性能的。

# 有什么索引优化

前缀索引优化；

覆盖索引优化；

主键索引最好是自增的；

防止索引失效；

### 前缀索引优化

使用某个字段中字符串的前几个字符建立索引，是为了减小索引字段大小，可以增加一个索引页中存储的索引值，有效提高索引的查询速度。在一些大字符串的字段作为索引时，使用前缀索引可以帮助我们减小索引项的大小。

### 覆盖索引优化

覆盖索引是指 SQL 中 query 的所有字段，在索引 B+Tree 的叶子节点上都能找得到的那些索引，从二级索引中查询得到记录，而不需要通过聚簇索引查询获得，可以避免回表的操作。

假设我们只需要查询商品的名称、价格，有什么方式可以避免回表呢？

我们可以建立一个联合索引，即「商品ID、名称、价格」作为一个联合索引。如果索引中存在这些数据，查询将不会再次检索主键索引，从而避免回表。

所以，使用覆盖索引的好处就是，不需要查询出包含整行记录的所有信息，也就减少了大量的 I/O 操作。

### 主键索引最好是自增的

InnoDB 创建主键索引默认为聚簇索引，数据被存放在了 B+Tree 的叶子节点上。也就是说，同一个叶子节点内的各个数据是按主键顺序存放的，因此，每当有一条新的数据插入时，数据库会根据主键将其插入到对应的叶子节点中。

如果我们使用自增主键，那么每次插入的新数据就会按顺序添加到当前索引节点的位置，不需要移动已有的数据，当页面写满，就会自动开辟一个新页面。因为每次插入一条新记录，都是追加操作，不需要重新移动数据，因此这种插入数据的方法效率非常高。

另外，主键字段的长度不要太大，因为主键字段长度越小，意味着二级索引的叶子节点越小（二级索引的叶子节点存放的数据是主键值），这样二级索引占用的空间也就越小。

### 索引最好设置为 NOT NULL

第一原因：索引列存在 NULL 就会导致优化器在做索引选择的时候更加复杂，更加难以优化，因为可为 NULL 的列会使索引、索引统计和值比较都更复杂，比如进行索引统计时，count 会省略值为NULL 的行。

第二个原因：NULL 值是一个没意义的值，但是它会占用物理空间，所以会带来的存储空间的问题，因为 InnoDB 存储记录的时候，如果表中存在允许为 NULL 的字段，那么行格式 (opens new window)中至少会用 1 字节空间存储 NULL 值列表。

### 防止索引失效

用上了索引并不意味着查询的时候会使用到索引，所以我们心里要清楚有哪些情况会导致索引失效，从而避免写出索引失效的查询语句，否则这样的查询效率是很低的。

这里简单说一下，发生索引失效的情况：

当我们使用左或者左右模糊匹配的时候，也就是 like %xx 或者 like %xx%这两种方式都会造成索引失效；

当我们在查询条件中对索引列做了计算、函数、类型转换操作，这些情况下都会造成索引失效；

联合索引要能正确使用需要遵循最左匹配原则，也就是按照最左优先的方式进行索引的匹配，否则就会导致索引失效。

在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。

type 字段就是描述了找到所需数据时使用的扫描方式是什么，常见扫描类型的执行效率从低到高的顺序为：

All（全表扫描）：对表进行全扫描；

index（全索引扫描）：对索引表进行全扫描；

range（索引范围扫描）：where中会用>，<等关键字；

ref（非唯一索引扫描）；

eq_ref（唯一索引扫描）：常用语多表查询；

const（结果只有一条的主键或唯一索引扫描）：与常量比较，效率最高。

![img](https://baiyunshan.flowus.net.cn/oss/8c85863b-83ee-4d8a-9d5b-eb638ce19db4/image.png?time=1713609900&token=73a65f1eccfaf0a26e0671bd5b275b24&role=sharePaid)

# count(\*) 和 count(1) 有什么区别？哪个性能最好？

count(\*)与count(1)相同，都是优先采用二级索引，否则才用聚簇索引。而且不需要读取记录中的值。

count(主键字段)也是优先用二级索引，否则才用聚簇索引，但需要读取记录判断是否为NULL，故效率稍微低一些。

count(字段)则是用全标扫描，效率最低。

![img](https://baiyunshan.flowus.net.cn/oss/1b799bb9-ee69-4362-9eb7-96771450c3a0/image.png?time=1713609900&token=f12521674bcf0a2117d0a2f67786e043&role=sharePaid)

count() 是一个聚合函数，函数的参数不仅可以是字段名，也可以是其他任意表达式，该函数作用是统计符合查询条件的记录中，函数指定的参数不为 NULL 的记录有多少个。

count(字段)：统计某个字段不为NULL的记录有多少个，例如count(name)就是统计name字段中不为NULL的记录有多少个；

count(1)：统计表中有多少个记录，无论是否为NULL；

count(主键字段)：统计表中主键字段的数量；

count(_)：count(_) 其实等于 count(0)，统计表中有多少个记录，无论是否为NULL（作用与count(1))相同。

### 小结：

count(1)、 count(\*)、 count(主键字段)在执行的时候，如果表里存在二级索引，优化器就会选择二级索引进行扫描。

所以，如果要执行 count(1)、 count(\*)、 count(主键字段) 时，尽量在数据表上建立二级索引，这样优化器会自动采用 key_len 最小的二级索引进行扫描，相比于扫描主键索引效率会高一些。

再来，就是不要使用 count(字段) 来统计记录个数，因为它的效率是最差的，会采用全表扫描的方式来统计。如果你非要统计表中该字段不为 NULL 的记录个数，建议给这个字段建立一个二级索引。

### count(主键字段)执行过程是怎么样的？

在通过 count 函数统计有多少个记录时，MySQL 的 server 层会维护一个名叫 count 的变量。server 层会循环向 InnoDB 读取一条记录，如果 count 函数指定的参数不为 NULL，那么就会将变量 count 加 1，直到符合查询的全部记录被读完，就退出循环。最后将 count 变量的值发送给客户端。

InnoDB 是通过 B+ 树来保存记录的，根据索引的类型又分为聚簇索引和二级索引，它们区别在于：

聚簇索引的叶子节点存放的是实际数据；

二级索引的叶子节点存放的是主键值，而不是实际数据。

对于逐渐索引（如下语句），执行过程是（优先使用二级索引，否则使用聚簇索引）：

select count(id) from t_order;

1

如果表里只有主键索引，没有二级索引时，那么，InnoDB 循环遍历聚簇索引，将读取到的记录返回给 server 层，然后读取记录中的 id 值，就会 id 值判断是否为 NULL，如果不为 NULL，就将 count 变量加 1。

2

如果表里有二级索引时，InnoDB 循环遍历的对象就不是聚簇索引，而是二级索引。因为二级索引叶子结点存放的是主键值，而不是实际数据，所以遍历速度更快，

### count(1)执行过程是怎么样的？

select count(1) from t_order;

1

如果表里只有聚簇索引，没有二级索引：

那么，InnoDB 循环遍历聚簇索引（主键索引），将读取到的记录返回给 server 层，但是不会读取记录中的任何字段的值，因为 count 函数的参数是 1，不是字段，所以不需要读取记录中的字段值。参数 1 很明显并不是 NULL，因此 server 层每从 InnoDB 读取到一条记录，就将 count 变量加 1。

可以看到，count(1) 相比 count(主键字段) 少一个步骤，就是不需要读取记录中的字段值，所以通常会说 count(1) 执行效率会比 count(主键字段) 高一点。

2

如果表里有二级索引，那优先使用二级索引。

### count(\*) 执行过程是怎样的？

看到 \* 这个字符的时候，是不是大家觉得是读取记录中的所有字段值？

对于 selete _ 这条语句来说是这个意思，但是在 count(_) 中并不是这个意思。

count(\*) 其实等于 count(0)，统计表中有多少个记录，无论是否为NULL（作用与count(1))相同。

优先使用二级索引，否则使用聚簇索引。

### count(字段) 执行过程是怎样的？

count(字段) 的执行效率相比前面的 count(1)、 count(\*)、 count(主键字段) 执行效率是最差的。

select count(name) from t_order;

对于这个查询来说，会采用全表扫描的方式来计数，所以它的执行效率是比较差的。

# 如何优化 count(\*)？

如果表很大，经常用count(\*)做统计是不好的。

1

近似值：我们可以使用 show table status 或者 explain 命令来表进行估算，得到一个大致的值；

2

额外表保存计数值：将记录的总数用额外的一个表维护，但在新增和删除需要额外花销。
